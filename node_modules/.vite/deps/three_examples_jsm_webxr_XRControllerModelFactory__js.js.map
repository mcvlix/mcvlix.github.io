{
  "version": 3,
  "sources": ["../../three/examples/jsm/libs/motion-controllers.module.js", "../../three/examples/jsm/webxr/XRControllerModelFactory.js"],
  "sourcesContent": ["/**\r\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\r\n */\r\n\r\nconst Constants = {\r\n  Handedness: Object.freeze({\r\n    NONE: 'none',\r\n    LEFT: 'left',\r\n    RIGHT: 'right'\r\n  }),\r\n\r\n  ComponentState: Object.freeze({\r\n    DEFAULT: 'default',\r\n    TOUCHED: 'touched',\r\n    PRESSED: 'pressed'\r\n  }),\r\n\r\n  ComponentProperty: Object.freeze({\r\n    BUTTON: 'button',\r\n    X_AXIS: 'xAxis',\r\n    Y_AXIS: 'yAxis',\r\n    STATE: 'state'\r\n  }),\r\n\r\n  ComponentType: Object.freeze({\r\n    TRIGGER: 'trigger',\r\n    SQUEEZE: 'squeeze',\r\n    TOUCHPAD: 'touchpad',\r\n    THUMBSTICK: 'thumbstick',\r\n    BUTTON: 'button'\r\n  }),\r\n\r\n  ButtonTouchThreshold: 0.05,\r\n\r\n  AxisTouchThreshold: 0.1,\r\n\r\n  VisualResponseProperty: Object.freeze({\r\n    TRANSFORM: 'transform',\r\n    VISIBILITY: 'visibility'\r\n  })\r\n};\r\n\r\n/**\r\n * @description Static helper function to fetch a JSON file and turn it into a JS object\r\n * @param {string} path - Path to JSON file to be fetched\r\n */\r\nasync function fetchJsonFile(path) {\r\n  const response = await fetch(path);\r\n  if (!response.ok) {\r\n    throw new Error(response.statusText);\r\n  } else {\r\n    return response.json();\r\n  }\r\n}\r\n\r\nasync function fetchProfilesList(basePath) {\r\n  if (!basePath) {\r\n    throw new Error('No basePath supplied');\r\n  }\r\n\r\n  const profileListFileName = 'profilesList.json';\r\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\r\n  return profilesList;\r\n}\r\n\r\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\r\n  if (!xrInputSource) {\r\n    throw new Error('No xrInputSource supplied');\r\n  }\r\n\r\n  if (!basePath) {\r\n    throw new Error('No basePath supplied');\r\n  }\r\n\r\n  // Get the list of profiles\r\n  const supportedProfilesList = await fetchProfilesList(basePath);\r\n\r\n  // Find the relative path to the first requested profile that is recognized\r\n  let match;\r\n  xrInputSource.profiles.some((profileId) => {\r\n    const supportedProfile = supportedProfilesList[profileId];\r\n    if (supportedProfile) {\r\n      match = {\r\n        profileId,\r\n        profilePath: `${basePath}/${supportedProfile.path}`,\r\n        deprecated: !!supportedProfile.deprecated\r\n      };\r\n    }\r\n    return !!match;\r\n  });\r\n\r\n  if (!match) {\r\n    if (!defaultProfile) {\r\n      throw new Error('No matching profile name found');\r\n    }\r\n\r\n    const supportedProfile = supportedProfilesList[defaultProfile];\r\n    if (!supportedProfile) {\r\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\r\n    }\r\n\r\n    match = {\r\n      profileId: defaultProfile,\r\n      profilePath: `${basePath}/${supportedProfile.path}`,\r\n      deprecated: !!supportedProfile.deprecated\r\n    };\r\n  }\r\n\r\n  const profile = await fetchJsonFile(match.profilePath);\r\n\r\n  let assetPath;\r\n  if (getAssetPath) {\r\n    let layout;\r\n    if (xrInputSource.handedness === 'any') {\r\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\r\n    } else {\r\n      layout = profile.layouts[xrInputSource.handedness];\r\n    }\r\n    if (!layout) {\r\n      throw new Error(\r\n        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`\r\n      );\r\n    }\r\n\r\n    if (layout.assetPath) {\r\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\r\n    }\r\n  }\r\n\r\n  return { profile, assetPath };\r\n}\r\n\r\n/** @constant {Object} */\r\nconst defaultComponentValues = {\r\n  xAxis: 0,\r\n  yAxis: 0,\r\n  button: 0,\r\n  state: Constants.ComponentState.DEFAULT\r\n};\r\n\r\n/**\r\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\r\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\r\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\r\n * range of motion and touchpads do not report touch locations off their physical bounds.\r\n * @param {number} x The original x coordinate in the range -1 to 1\r\n * @param {number} y The original y coordinate in the range -1 to 1\r\n */\r\nfunction normalizeAxes(x = 0, y = 0) {\r\n  let xAxis = x;\r\n  let yAxis = y;\r\n\r\n  // Determine if the point is outside the bounds of the circle\r\n  // and, if so, place it on the edge of the circle\r\n  const hypotenuse = Math.sqrt((x * x) + (y * y));\r\n  if (hypotenuse > 1) {\r\n    const theta = Math.atan2(y, x);\r\n    xAxis = Math.cos(theta);\r\n    yAxis = Math.sin(theta);\r\n  }\r\n\r\n  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\r\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\r\n  const result = {\r\n    normalizedXAxis: (xAxis * 0.5) + 0.5,\r\n    normalizedYAxis: (yAxis * 0.5) + 0.5\r\n  };\r\n  return result;\r\n}\r\n\r\n/**\r\n * Contains the description of how the 3D model should visually respond to a specific user input.\r\n * This is accomplished by initializing the object with the name of a node in the 3D model and\r\n * property that need to be modified in response to user input, the name of the nodes representing\r\n * the allowable range of motion, and the name of the input which triggers the change. In response\r\n * to the named input changing, this object computes the appropriate weighting to use for\r\n * interpolating between the range of motion nodes.\r\n */\r\nclass VisualResponse {\r\n  constructor(visualResponseDescription) {\r\n    this.componentProperty = visualResponseDescription.componentProperty;\r\n    this.states = visualResponseDescription.states;\r\n    this.valueNodeName = visualResponseDescription.valueNodeName;\r\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\r\n\r\n    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {\r\n      this.minNodeName = visualResponseDescription.minNodeName;\r\n      this.maxNodeName = visualResponseDescription.maxNodeName;\r\n    }\r\n\r\n    // Initializes the response's current value based on default data\r\n    this.value = 0;\r\n    this.updateFromComponent(defaultComponentValues);\r\n  }\r\n\r\n  /**\r\n   * Computes the visual response's interpolation weight based on component state\r\n   * @param {Object} componentValues - The component from which to update\r\n   * @param {number} xAxis - The reported X axis value of the component\r\n   * @param {number} yAxis - The reported Y axis value of the component\r\n   * @param {number} button - The reported value of the component's button\r\n   * @param {string} state - The component's active state\r\n   */\r\n  updateFromComponent({\r\n    xAxis, yAxis, button, state\r\n  }) {\r\n    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);\r\n    switch (this.componentProperty) {\r\n      case Constants.ComponentProperty.X_AXIS:\r\n        this.value = (this.states.includes(state)) ? normalizedXAxis : 0.5;\r\n        break;\r\n      case Constants.ComponentProperty.Y_AXIS:\r\n        this.value = (this.states.includes(state)) ? normalizedYAxis : 0.5;\r\n        break;\r\n      case Constants.ComponentProperty.BUTTON:\r\n        this.value = (this.states.includes(state)) ? button : 0;\r\n        break;\r\n      case Constants.ComponentProperty.STATE:\r\n        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {\r\n          this.value = (this.states.includes(state));\r\n        } else {\r\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\r\n    }\r\n  }\r\n}\r\n\r\nclass Component {\r\n  /**\r\n   * @param {Object} componentId - Id of the component\r\n   * @param {Object} componentDescription - Description of the component to be created\r\n   */\r\n  constructor(componentId, componentDescription) {\r\n    if (!componentId\r\n     || !componentDescription\r\n     || !componentDescription.visualResponses\r\n     || !componentDescription.gamepadIndices\r\n     || Object.keys(componentDescription.gamepadIndices).length === 0) {\r\n      throw new Error('Invalid arguments supplied');\r\n    }\r\n\r\n    this.id = componentId;\r\n    this.type = componentDescription.type;\r\n    this.rootNodeName = componentDescription.rootNodeName;\r\n    this.touchPointNodeName = componentDescription.touchPointNodeName;\r\n\r\n    // Build all the visual responses for this component\r\n    this.visualResponses = {};\r\n    Object.keys(componentDescription.visualResponses).forEach((responseName) => {\r\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\r\n      this.visualResponses[responseName] = visualResponse;\r\n    });\r\n\r\n    // Set default values\r\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\r\n\r\n    this.values = {\r\n      state: Constants.ComponentState.DEFAULT,\r\n      button: (this.gamepadIndices.button !== undefined) ? 0 : undefined,\r\n      xAxis: (this.gamepadIndices.xAxis !== undefined) ? 0 : undefined,\r\n      yAxis: (this.gamepadIndices.yAxis !== undefined) ? 0 : undefined\r\n    };\r\n  }\r\n\r\n  get data() {\r\n    const data = { id: this.id, ...this.values };\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @description Poll for updated data based on current gamepad state\r\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\r\n   */\r\n  updateFromGamepad(gamepad) {\r\n    // Set the state to default before processing other data sources\r\n    this.values.state = Constants.ComponentState.DEFAULT;\r\n\r\n    // Get and normalize button\r\n    if (this.gamepadIndices.button !== undefined\r\n        && gamepad.buttons.length > this.gamepadIndices.button) {\r\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\r\n      this.values.button = gamepadButton.value;\r\n      this.values.button = (this.values.button < 0) ? 0 : this.values.button;\r\n      this.values.button = (this.values.button > 1) ? 1 : this.values.button;\r\n\r\n      // Set the state based on the button\r\n      if (gamepadButton.pressed || this.values.button === 1) {\r\n        this.values.state = Constants.ComponentState.PRESSED;\r\n      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {\r\n        this.values.state = Constants.ComponentState.TOUCHED;\r\n      }\r\n    }\r\n\r\n    // Get and normalize x axis value\r\n    if (this.gamepadIndices.xAxis !== undefined\r\n        && gamepad.axes.length > this.gamepadIndices.xAxis) {\r\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\r\n      this.values.xAxis = (this.values.xAxis < -1) ? -1 : this.values.xAxis;\r\n      this.values.xAxis = (this.values.xAxis > 1) ? 1 : this.values.xAxis;\r\n\r\n      // If the state is still default, check if the xAxis makes it touched\r\n      if (this.values.state === Constants.ComponentState.DEFAULT\r\n        && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {\r\n        this.values.state = Constants.ComponentState.TOUCHED;\r\n      }\r\n    }\r\n\r\n    // Get and normalize Y axis value\r\n    if (this.gamepadIndices.yAxis !== undefined\r\n        && gamepad.axes.length > this.gamepadIndices.yAxis) {\r\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\r\n      this.values.yAxis = (this.values.yAxis < -1) ? -1 : this.values.yAxis;\r\n      this.values.yAxis = (this.values.yAxis > 1) ? 1 : this.values.yAxis;\r\n\r\n      // If the state is still default, check if the yAxis makes it touched\r\n      if (this.values.state === Constants.ComponentState.DEFAULT\r\n        && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {\r\n        this.values.state = Constants.ComponentState.TOUCHED;\r\n      }\r\n    }\r\n\r\n    // Update the visual response weights based on the current component data\r\n    Object.values(this.visualResponses).forEach((visualResponse) => {\r\n      visualResponse.updateFromComponent(this.values);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n  * @description Builds a motion controller with components and visual responses based on the\r\n  * supplied profile description. Data is polled from the xrInputSource's gamepad.\r\n  * @author Nell Waliczek / https://github.com/NellWaliczek\r\n*/\r\nclass MotionController {\r\n  /**\r\n   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around\r\n   * @param {Object} profile - The best matched profile description for the supplied xrInputSource\r\n   * @param {Object} assetUrl\r\n   */\r\n  constructor(xrInputSource, profile, assetUrl) {\r\n    if (!xrInputSource) {\r\n      throw new Error('No xrInputSource supplied');\r\n    }\r\n\r\n    if (!profile) {\r\n      throw new Error('No profile supplied');\r\n    }\r\n\r\n    this.xrInputSource = xrInputSource;\r\n    this.assetUrl = assetUrl;\r\n    this.id = profile.profileId;\r\n\r\n    // Build child components as described in the profile description\r\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\r\n    this.components = {};\r\n    Object.keys(this.layoutDescription.components).forEach((componentId) => {\r\n      const componentDescription = this.layoutDescription.components[componentId];\r\n      this.components[componentId] = new Component(componentId, componentDescription);\r\n    });\r\n\r\n    // Initialize components based on current gamepad state\r\n    this.updateFromGamepad();\r\n  }\r\n\r\n  get gripSpace() {\r\n    return this.xrInputSource.gripSpace;\r\n  }\r\n\r\n  get targetRaySpace() {\r\n    return this.xrInputSource.targetRaySpace;\r\n  }\r\n\r\n  /**\r\n   * @description Returns a subset of component data for simplified debugging\r\n   */\r\n  get data() {\r\n    const data = [];\r\n    Object.values(this.components).forEach((component) => {\r\n      data.push(component.data);\r\n    });\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * @description Poll for updated data based on current gamepad state\r\n   */\r\n  updateFromGamepad() {\r\n    Object.values(this.components).forEach((component) => {\r\n      component.updateFromGamepad(this.xrInputSource.gamepad);\r\n    });\r\n  }\r\n}\r\n\r\nexport { Constants, MotionController, fetchProfile, fetchProfilesList };\r\n", "import {\r\n\tMesh,\r\n\tMeshBasicMaterial,\r\n\tObject3D,\r\n\tSphereGeometry,\r\n} from 'three';\r\n\r\nimport { GLTFLoader } from '../loaders/GLTFLoader.js';\r\n\r\nimport {\r\n\tConstants as MotionControllerConstants,\r\n\tfetchProfile,\r\n\tMotionController\r\n} from '../libs/motion-controllers.module.js';\r\n\r\nconst DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\r\nconst DEFAULT_PROFILE = 'generic-trigger';\r\n\r\nclass XRControllerModel extends Object3D {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.motionController = null;\r\n\t\tthis.envMap = null;\r\n\r\n\t}\r\n\r\n\tsetEnvironmentMap( envMap ) {\r\n\r\n\t\tif ( this.envMap == envMap ) {\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.envMap = envMap;\r\n\t\tthis.traverse( ( child ) => {\r\n\r\n\t\t\tif ( child.isMesh ) {\r\n\r\n\t\t\t\tchild.material.envMap = this.envMap;\r\n\t\t\t\tchild.material.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Polls data from the XRInputSource and updates the model's components to match\r\n\t * the real world data\r\n\t */\r\n\tupdateMatrixWorld( force ) {\r\n\r\n\t\tsuper.updateMatrixWorld( force );\r\n\r\n\t\tif ( ! this.motionController ) return;\r\n\r\n\t\t// Cause the MotionController to poll the Gamepad for data\r\n\t\tthis.motionController.updateFromGamepad();\r\n\r\n\t\t// Update the 3D model to reflect the button, thumbstick, and touchpad state\r\n\t\tObject.values( this.motionController.components ).forEach( ( component ) => {\r\n\r\n\t\t\t// Update node data based on the visual responses' current states\r\n\t\t\tObject.values( component.visualResponses ).forEach( ( visualResponse ) => {\r\n\r\n\t\t\t\tconst { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;\r\n\r\n\t\t\t\t// Skip if the visual response node is not found. No error is needed,\r\n\t\t\t\t// because it will have been reported at load time.\r\n\t\t\t\tif ( ! valueNode ) return;\r\n\r\n\t\t\t\t// Calculate the new properties based on the weight supplied\r\n\t\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY ) {\r\n\r\n\t\t\t\t\tvalueNode.visible = value;\r\n\r\n\t\t\t\t} else if ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\r\n\r\n\t\t\t\t\tvalueNode.quaternion.slerpQuaternions(\r\n\t\t\t\t\t\tminNode.quaternion,\r\n\t\t\t\t\t\tmaxNode.quaternion,\r\n\t\t\t\t\t\tvalue\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tvalueNode.position.lerpVectors(\r\n\t\t\t\t\t\tminNode.position,\r\n\t\t\t\t\t\tmaxNode.position,\r\n\t\t\t\t\t\tvalue\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Walks the model's tree to find the nodes needed to animate the components and\r\n * saves them to the motionContoller components for use in the frame loop. When\r\n * touchpads are found, attaches a touch dot to them.\r\n */\r\nfunction findNodes( motionController, scene ) {\r\n\r\n\t// Loop through the components and find the nodes needed for each components' visual responses\r\n\tObject.values( motionController.components ).forEach( ( component ) => {\r\n\r\n\t\tconst { type, touchPointNodeName, visualResponses } = component;\r\n\r\n\t\tif ( type === MotionControllerConstants.ComponentType.TOUCHPAD ) {\r\n\r\n\t\t\tcomponent.touchPointNode = scene.getObjectByName( touchPointNodeName );\r\n\t\t\tif ( component.touchPointNode ) {\r\n\r\n\t\t\t\t// Attach a touch dot to the touchpad.\r\n\t\t\t\tconst sphereGeometry = new SphereGeometry( 0.001 );\r\n\t\t\t\tconst material = new MeshBasicMaterial( { color: 0x0000FF } );\r\n\t\t\t\tconst sphere = new Mesh( sphereGeometry, material );\r\n\t\t\t\tcomponent.touchPointNode.add( sphere );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( `Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}` );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Loop through all the visual responses to be applied to this component\r\n\t\tObject.values( visualResponses ).forEach( ( visualResponse ) => {\r\n\r\n\t\t\tconst { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;\r\n\r\n\t\t\t// If animating a transform, find the two nodes to be interpolated between.\r\n\t\t\tif ( valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM ) {\r\n\r\n\t\t\t\tvisualResponse.minNode = scene.getObjectByName( minNodeName );\r\n\t\t\t\tvisualResponse.maxNode = scene.getObjectByName( maxNodeName );\r\n\r\n\t\t\t\t// If the extents cannot be found, skip this animation\r\n\t\t\t\tif ( ! visualResponse.minNode ) {\r\n\r\n\t\t\t\t\tconsole.warn( `Could not find ${minNodeName} in the model` );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! visualResponse.maxNode ) {\r\n\r\n\t\t\t\t\tconsole.warn( `Could not find ${maxNodeName} in the model` );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// If the target node cannot be found, skip this animation\r\n\t\t\tvisualResponse.valueNode = scene.getObjectByName( valueNodeName );\r\n\t\t\tif ( ! visualResponse.valueNode ) {\r\n\r\n\t\t\t\tconsole.warn( `Could not find ${valueNodeName} in the model` );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t} );\r\n\r\n}\r\n\r\nfunction addAssetSceneToControllerModel( controllerModel, scene ) {\r\n\r\n\t// Find the nodes needed for animation and cache them on the motionController.\r\n\tfindNodes( controllerModel.motionController, scene );\r\n\r\n\t// Apply any environment map that the mesh already has set.\r\n\tif ( controllerModel.envMap ) {\r\n\r\n\t\tscene.traverse( ( child ) => {\r\n\r\n\t\t\tif ( child.isMesh ) {\r\n\r\n\t\t\t\tchild.material.envMap = controllerModel.envMap;\r\n\t\t\t\tchild.material.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// Add the glTF scene to the controllerModel.\r\n\tcontrollerModel.add( scene );\r\n\r\n}\r\n\r\nclass XRControllerModelFactory {\r\n\r\n\tconstructor( gltfLoader = null ) {\r\n\r\n\t\tthis.gltfLoader = gltfLoader;\r\n\t\tthis.path = DEFAULT_PROFILES_PATH;\r\n\t\tthis._assetCache = {};\r\n\r\n\t\t// If a GLTFLoader wasn't supplied to the constructor create a new one.\r\n\t\tif ( ! this.gltfLoader ) {\r\n\r\n\t\t\tthis.gltfLoader = new GLTFLoader();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcreateControllerModel( controller ) {\r\n\r\n\t\tconst controllerModel = new XRControllerModel();\r\n\t\tlet scene = null;\r\n\r\n\t\tcontroller.addEventListener( 'connected', ( event ) => {\r\n\r\n\t\t\tconst xrInputSource = event.data;\r\n\r\n\t\t\tif ( xrInputSource.targetRayMode !== 'tracked-pointer' || ! xrInputSource.gamepad ) return;\r\n\r\n\t\t\tfetchProfile( xrInputSource, this.path, DEFAULT_PROFILE ).then( ( { profile, assetPath } ) => {\r\n\r\n\t\t\t\tcontrollerModel.motionController = new MotionController(\r\n\t\t\t\t\txrInputSource,\r\n\t\t\t\t\tprofile,\r\n\t\t\t\t\tassetPath\r\n\t\t\t\t);\r\n\r\n\t\t\t\tconst cachedAsset = this._assetCache[ controllerModel.motionController.assetUrl ];\r\n\t\t\t\tif ( cachedAsset ) {\r\n\r\n\t\t\t\t\tscene = cachedAsset.scene.clone();\r\n\r\n\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ! this.gltfLoader ) {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'GLTFLoader not set.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.gltfLoader.setPath( '' );\r\n\t\t\t\t\tthis.gltfLoader.load( controllerModel.motionController.assetUrl, ( asset ) => {\r\n\r\n\t\t\t\t\t\tthis._assetCache[ controllerModel.motionController.assetUrl ] = asset;\r\n\r\n\t\t\t\t\t\tscene = asset.scene.clone();\r\n\r\n\t\t\t\t\t\taddAssetSceneToControllerModel( controllerModel, scene );\r\n\r\n\t\t\t\t\t},\r\n\t\t\t\t\tnull,\r\n\t\t\t\t\t() => {\r\n\r\n\t\t\t\t\t\tthrow new Error( `Asset ${controllerModel.motionController.assetUrl} missing or malformed.` );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} ).catch( ( err ) => {\r\n\r\n\t\t\t\tconsole.warn( err );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\tcontroller.addEventListener( 'disconnected', () => {\r\n\r\n\t\t\tcontrollerModel.motionController = null;\r\n\t\t\tcontrollerModel.remove( scene );\r\n\t\t\tscene = null;\r\n\r\n\t\t} );\r\n\r\n\t\treturn controllerModel;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { XRControllerModelFactory };\r\n"],
  "mappings": "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",
  "names": []
}
